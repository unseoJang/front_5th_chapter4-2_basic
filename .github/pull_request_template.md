# 과제 체크포인트

Cloud Front url : https://depwjaojfbxzd.cloudfront.net/

## 과제 요구사항 만족

- [x] 배포 후 url 제출
- [x] 성능 개선 보고서 작성

- [x] Lighthouse 점수 이해
- [x] Core Web Vital 이해

## 과제 셀프회고

이번 4-2 Basic 과제는 난이도 자체는 어렵지 않았지만, 그만큼 자칫하면 중요하지만 간과하기 쉬운 웹 퍼포먼스 영역에 대해 다시금 생각하게 만드는 과제였다.

퍼블리셔 시절에는 외부 화면에 노출되는 코드를 다루면서 Lighthouse 점수나 이미지 최적화에 민감하게 반응했었지만, 프론트엔드 개발자로 전향하고 나서는 주로 내부 서비스나 관리자 페이지 위주로 작업하면서 성능 지표를 크게 신경 쓰지 않았던 것 같다.

이번 과제를 통해 다시 한번 LCP, FCP, CLS 같은 Core Web Vitals 지표를 이해하고, 이를 개선하기 위한 preload, preconnect, WebP 포맷, fetchpriority 같은 기법들을 적용해볼 수 있었다. 실제로 Hero 이미지 최적화만으로도 LCP가 3.1초에서 1.81초로 줄어드는 개선을 경험하면서, 단순히 “이미지 용량을 줄여야 한다”는 차원을 넘어서 “언제 어떻게 불러오는지도 중요하다”는 사실을 체감했다.

앞으로는 기능 구현뿐 아니라 성능까지 고려하는 프론트엔드 개발자가 되기 위해, 외부 페이지 작업 시 Lighthouse 체크를 습관화하고 주요 자산에는 preload 전략을 적극 활용할 계획이다.

### 기술적 성장

- 새로 학습한 개념
  - Core Web Vitals와 Lighthouse 지표를 단순히 로컬 개발환경에서나 Chrome 에서 플러그인을 통해 수동으로 확인하는 것이 아니라, GitHub Workflows를 통해 .yml 설정 파일로 등록하면 배포 시점마다 자동으로 점검할 수 있다는 점을 처음 알게 되었다. 이를 통해 CI 단계에서부터 성능을 모니터링하고 품질을 통합 관리할 수 있다는 개념을 체득했다.
  
	- <picture> 태그를 활용하면 img 태그에 단순히 display: none / block으로 대응하는 것보다 훨씬 효율적이고 SEO 친화적인 방식으로 반응형 이미지를 구성할 수 있다는 점을 배웠다. 특히 WebP, AVIF 같은 차세대 이미지 포맷을 조건부로 제공하고, fallback을 명시할 수 있어 성능 개선에도 큰 효과가 있다는 사실을 확인했다.

- 기존 지식의 재발견/심화

  - 퍼블리셔 시절에 익숙했던 웹 접근성과 이미지 최적화 개념을 프론트엔드 개발자로 다시 되짚어보며, 단순히 시멘틱 마크업에 그치는 것이 아니라 실제 성능과 지표, 사용자 경험에 어떤 영향을 주는지 보다 명확히 이해할 수 있었다.

	- HTML은 마크업 언어, CSS는 스타일 언어 라고 생각해왔지만, 브라우저 렌더링 과정과 긴밀히 연결되어 있고 작은 선택 하나가 성능 지표에 영향을 줄 수 있다는 점을 실전에서 다시 체감했다.
- 구현 과정에서의 기술적 도전과 해결

  - LCP 개선을 위해 preload, fetchpriority, preconnect 등 다양한 퍼포먼스 최적화 전략을 단계적으로 적용해보면서, 브라우저가 리소스를 어떻게 로딩 우선순위로 처리하는지를 실험적으로 확인해볼 수 있었다.

  - 또한 외부 스크립트와 폰트, 이미지가 퍼포먼스에 미치는 영향을 파악하고, defer, as="image", type="webp" 등 속성을 적절히 조합하는 방식으로 렌더링 차단 요소를 줄이는 데 성공하고 해당 부분들을 github issue 탭을 통해 직접 눈으로 확인 가능했다.

### 코드 품질
- 특히 만족스러운 구현
```html
<picture>
  <source media="(min-width: 960px)" srcset="images/Hero_Desktop.webp" type="image/webp">
  <source media="(min-width: 579px)" srcset="images/Hero_Tablet.webp" type="image/webp">
  <img src="images/Hero_Mobile.webp" alt="VR Headsets Hero Image" fetchpriority="high" width="1440" height="600" style="width: 100%; height: auto;">
</picture>
```
이 코드는 이번 과제를 통해 처음 제대로 사용해본 <picture> 태그 구현이다. 이전까지는 img 태그에 여러 클래스를 붙여 display: none/block으로 뷰포트 크기에 따라 이미지를 제어했었는데, 이 방식은 모든 이미지를 동시에 불러와 브라우저 리소스를 낭비하게 된다는 단점이 있었다.

반면 <picture> 태그를 활용하면 브라우저가 화면 크기에 맞춰 필요한 이미지만 선택적으로 로딩하기 때문에, 성능 개선은 물론 SEO 측면에서도 훨씬 효율적이라는 점을 알게 되었다. 특히 WebP 같은 차세대 포맷과 fetchpriority, preload 등을 함께 적용하면서 이미지 하나가 페이지 성능에 얼마나 큰 영향을 줄 수 있는지를 직접 체감할 수 있었다.

```css
@font-face {
  font-family: 'Heebo';
  src: url('../fonts/Heebo-Regular.woff2') format('woff2');
}
@font-face {
  font-family: 'Heebo';
  src: url('../fonts/Heebo-Bold.woff2') format('woff2');
}
/* 이하 생략 */
```
이번 과제에서는 기존에 Google Fonts CDN을 통해 불러오던 Heebo 폰트를 직접 다운로드 받아 로컬에서 관리하도록 설정했다.
그동안은 <link href="https://fonts.googleapis.com/..."> 형태로 외부에서 폰트를 불러오곤 했는데, 과거 경험들을 생각해보면 네트워크 연결 상태에 따라 폰트 로딩 지연이 발생하거나 CORS 문제 등 예상치 못한 상황이 생기기도 했다.

로컬 폰트 적용을 통해 얻은 가장 큰 장점은 안정성과 성능 향상이었다.

외부 의존도가 줄어들어 로딩 속도와 일관성이 개선되었고,

.woff2 포맷을 사용해 브라우저 호환성과 용량 최적화도 함께 고려할 수 있었다.

또한, @font-face 선언에 font-display: swap; 속성을 추가함으로써 텍스트 렌더링 차단 없이 폰트가 적용되도록 설정하여 LCP 지표에도 긍정적인 영향을 주었다.
실제 페이지 퍼포먼스 점검에서 폰트 관련 경고가 사라지고, 텍스트 FOUT 문제도 개선되는 것을 확인할 수 있었다.

코드 설계 관련 고민: dns-prefetch, preconnect, preload의 선택 기준

이번 과제에서는 외부 리소스를 더 빠르게 불러오기 위해 dns-prefetch, preconnect, preload 세 가지를 적용할 수 있는 상황을 마주했다. 하지만 각각의 기능이 유사하면서도 미묘하게 다르기 때문에, 단순히 "성능 향상에 좋다니까 쓰자"가 아니라 어떤 리소스에 무엇을 적용할지 고민하며 전략적으로 접근하려고 했다.

- 코드 설계 관련 고민과 결정
✅ dns-prefetch 고민
처음에는 모든 외부 리소스에 dns-prefetch를 달고 시작했다. DNS lookup 비용을 줄일 수 있다는 건 알았지만, 실제로 얼마나 체감될까 하는 의문이 있었다.
결국 판단 기준은 **"꼭 안 써도 되는 리소스지만, 나중에 쓰일 수도 있는 외부 도메인"**이었다. 예를 들어 소셜 미디어 아이콘 링크 등은 사용자가 클릭해야 요청이 발생하기 때문에 dns-prefetch로만 처리했다.

✅ preconnect 고민
반면 preconnect는 DNS뿐 아니라 TCP, TLS까지 미리 연결해버리기 때문에 훨씬 강력하지만, 브라우저 커넥션 풀을 차지한다는 점이 걸렸다. 그래서 실제로 초기 렌더링에 반드시 사용되는 외부 리소스, 예를 들어 Google Fonts, CDN 이미지, CloudFront 등에는 preconnect를 적용하되, 꼭 필요한 것에만 제한적으로 사용했다.
특히 crossorigin이 필요한 도메인(fonts.gstatic.com)은 놓치기 쉬운 포인트였고, 테스트 중 preload나 preconnect가 제대로 작동하지 않던 이유도 이 속성 누락 때문이었다.

✅ preload 고민
그리고 가장 강력한 preload는 LCP 개선을 위해 Hero 이미지에만 집중적으로 적용했다. 다만, 이 역시 과하게 쓰면 렌더링에 필요한 리소스와 충돌하거나, 우선순위가 꼬일 수 있다는 점을 학습하며 신중하게 적용했다.
예를 들어 JS나 폰트를 preload로 여러 개 지정했을 때 이미지보다 먼저 불러오는 문제가 있어, Lighthouse의 리소스 우선순위 경고를 보며 튜닝했다.

결국 이번 과제의 목적은 Light House 의 점수 상향에 있기 때문에 나는 당장 렌더링에 필요한 내부 리소스라고 고려하여 preload 를 사용하였다.

참고 : https://ui.toast.com/posts/ko_202012101720

### 학습 효과 분석

- 가장 큰 배움이 있었던 부분
이번 과제에서 가장 큰 배움은 단순히 HTML과 CSS를 구성하는 것이 아닌, 브라우저 렌더링 흐름과 웹 성능 지표가 어떻게 연결되는지를 실제로 체험할 수 있었다는 점이다. 특히 LCP(Largest Contentful Paint), CLS, TBT 등의 개념이 Lighthouse와 Core Web Vitals를 통해 구체적으로 수치화되고, 어떤 요소가 영향을 주는지를 디버깅하며 실감했다.

- 추가 학습이 필요한 영역
preload, preconnect, fetchpriority와 같은 성능 최적화 기법들을 개별적으로 학습했지만, 각 브라우저별 처리 방식이나 우선순위 충돌, 여러 최적화 기술 간의 상호작용에 대해서는 아직 더 많은 실험과 학습이 필요하다고 느꼈다. 특히 JS 리소스와 이미지 리소스를 함께 preload할 때의 로딩 충돌 문제나, 서비스 규모가 커졌을 때의 네트워크 전략도 더 깊이 공부해보고 싶다.

- 실무 적용 가능성
웹 성능을 높이기 위한 접근은 단순한 기술이 아니라 사용자 경험의 핵심이라는 것을 이번 과제를 통해 확실히 인식하게 되었다. 앞으로 외부에 노출되는 페이지를 작업할 때는 HTML 구조뿐 아니라 로딩 우선순위, 이미지 포맷, 웹폰트 적용 방식까지 포함한 종합적인 퍼포먼스 설계를 실무에 적용하고 있었고 그 상태를 확실히 수치화하여 볼수있도록 구체화 시키고 싶다.

### 과제 피드백
- 과제에서 좋았던 부분
단순히 마크업을 작성하는 것이 아니라, 실제 배포 후 Lighthouse 점수를 기준으로 수정해보는 과정이 매우 인상 깊었다. "왜 점수가 떨어지는지", "어떤 코드를 어떻게 고치면 올라가는지"를 반복적으로 테스트하면서 진짜 퍼포먼스를 고민하는 경험을 할 수 있었다. 또한 단순히 기능 구현이 아니라 **"보이지 않는 품질"**을 챙기는 습관을 길러준 점이 좋았다.

- 과제에서 모호했던 부분
preconnect, dns-prefetch, preload와 같은 최적화 관련 개념이 교재나 가이드에 정리되어 있긴 했지만, 실무에서 언제 어떤 상황에 써야 하는지를 처음엔 분간하기 어려웠다. 특히 preload는 잘못 쓰면 오히려 렌더링을 늦추는 경우도 있어 실험과 검증 없이 적용하면 독이 될 수도 있다는 점에서 다소 모호하게 느껴져 GPT나 블로그를 통해 해당 내용을 학습할수 있었다. 이런 부분은 간단한 사례 중심으로 보완되면 더 좋았을 것 같다.

## 리뷰 받고 싶은 내용

- 혹시 지금의 리펙토링 상태에서 Light House 의 점수를 더 끌어올릴수 있는 부분이 있을까요?
- HTML 시멘틱 구조와 접근성 관점에서 보완할 점이 있는지
h1, h2 구조 정리, alt와 aria-label 사용 등 접근성을 고려했지만, 실무에서 놓치기 쉬운 마크업 패턴이나 더 좋은 대안이 있다면 알려주세요.